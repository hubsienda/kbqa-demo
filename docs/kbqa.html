<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Knowledge Base Q&A (with Citations)</title>
  <style>
    :root{--card-b:#eee;--muted:#555}
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;padding:24px;background:#fff}
    .card{max-width:860px;margin:0 auto 16px auto;padding:16px;border:1px solid var(--card-b);border-radius:14px}
    button{cursor:pointer}
    details summary{cursor:pointer}
    pre{white-space:pre-wrap;background:#fcfcfc;border:1px solid #eee;border-radius:10px;padding:10px;overflow:auto}
    .muted{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{padding:10px 12px;border-radius:10px}
    .btn-dark{border:0;background:#111;color:#fff}
    .btn-outline{border:1px solid #111;background:#fff}
    .pill{background:#fff;border:1px solid #eee;border-radius:10px;padding:8px}
  </style>
</head>
<body>

  <!-- Demo card -->
  <div id="kbqa" class="card">
    <h3 style="margin:0 0 6px">Knowledge Base Q&A (with Citations)</h3>
    <p style="margin:0 0 4px;color:#444">
      Upload 1–3 text-based PDFs, then ask a question. All processing happens in your browser.
    </p>
    <p class="muted" style="margin:0 0 12px">
      <strong>Privacy:</strong> Your files never leave your device — all processing happens locally in your browser.
    </p>

    <div class="row" style="margin-bottom:10px">
      <input id="kb-files" type="file" accept="application/pdf" multiple
             style="flex:1 1 320px;padding:8px;border:1px solid #ddd;border-radius:10px">
      <button id="kb-index" class="btn btn-dark">Index PDFs</button>
    </div>

    <div id="kb-status" class="muted" style="margin-bottom:8px"></div>

    <div class="row" style="align-items:flex-end">
      <input id="kb-q" placeholder="Ask a question…"
             style="flex:1 1 420px;padding:10px;border:1px solid #ddd;border-radius:10px">
      <button id="kb-ask" class="btn btn-dark" disabled>Answer</button>
      <button id="kb-reset" class="btn btn-outline">Reset</button>
      <button id="kb-save"  class="btn btn-outline">Download answer</button>
    </div>

    <div id="kb-out" style="display:none;margin-top:12px;padding:12px;background:#f8fafc;border-radius:12px"></div>

    <details style="margin-top:10px"><summary>See the logic (debug)</summary>
      <pre id="kb-json"></pre>
    </details>
  </div>

  <!-- How to use -->
  <div class="card">
    <h3 style="margin:0 0 8px">How to use this Q&A with Citations</h3>
    <ol style="margin:0 0 10px 18px;line-height:1.5">
      <li>Click <strong>Index PDFs</strong> and choose <strong>1–3 PDF files</strong> (e.g., product sheets). Use text-based PDFs (not scanned images).</li>
      <li>Wait for the status line to say <em>“Indexed … sentence chunks.”</em> The <strong>Answer</strong> button will become active.</li>
      <li>Type your question (e.g., “What are the storage conditions?”) and click <strong>Answer</strong>.</li>
      <li>Read the <strong>Answer (extractive)</strong> and verify the <strong>Citations</strong> cards (Document name • Page number + snippet).</li>
    </ol>
    <details style="margin-top:8px">
      <summary>Examples to try</summary>
      <ul style="margin:8px 0 0 18px;line-height:1.5">
        <li>“What are the shelf-life and storage temperature requirements?”</li>
        <li>“List the allergens and handling warnings.”</li>
        <li>“Which certifications are mentioned for this product?”</li>
        <li>“What are the pack sizes and pallet configuration?”</li>
      </ul>
    </details>
    <details style="margin-top:6px">
      <summary>Troubleshooting</summary>
      <ul style="margin:8px 0 0 18px;line-height:1.5">
        <li><strong>“Failed to read PDFs”</strong>: ensure the file is a standard, text-based PDF and try again.</li>
        <li><strong>No/poor results</strong>: the PDF may be a scan without OCR; use an OCR’d version.</li>
        <li><strong>Large files feel slow</strong>: try fewer pages or smaller files.</li>
      </ul>
    </details>
  </div>

  <!-- pdf.js UMD build that exposes window.pdfjsLib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Match worker version to avoid warnings.
    if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }

    (function(){
      const statusEl = document.getElementById('kb-status');
      const askBtn   = document.getElementById('kb-ask');
      const outEl    = document.getElementById('kb-out');
      const dbgEl    = document.getElementById('kb-json');
      const filesEl  = document.getElementById('kb-files');
      const qEl      = document.getElementById('kb-q');

      let index = [];      // {doc, page, text, tokens}
      let docNames = [];   // ["file1.pdf", ...]
      let lastAnswerText = ""; // for download

      function guardPdfjs(){
        if (typeof pdfjsLib === 'undefined') {
          statusEl.textContent = 'Failed to load pdf.js from CDN (pdfjsLib is undefined).';
          throw new Error('pdfjsLib not available');
        }
      }

      function showError(prefix, e){
        const msg = (e && (e.message || e.toString())) || 'Unknown error';
        statusEl.textContent = `${prefix}: ${msg}`;
        if (e && e.stack) dbgEl.textContent = e.stack;
        console.error(prefix, e);
      }

      function tokens(s){
        return (s||'').toLowerCase()
          .replace(/[^a-z0-9\s]/g,' ')
          .split(/\s+/).filter(w=>w && !stop.has(w));
      }
      const stop = new Set('a an the and or of for to with on in at by from as is are was were be have has had it this that these those which who whom whose into over under about per each than then thus hence due via vs etc not no yes your our their its if else when while whereas may might can could should will shall would do does did done just more most less least very nearly almost across within without above below before after during around between because until unless'.split(/\s+/));

      async function extractPDF(file){
        guardPdfjs();
        const arrayBuf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuf }).promise;
        const doc = { name: file.name, pages: [] };
        const maxPages = Math.min(pdf.numPages, 40); // safety cap
        for (let p = 1; p <= maxPages; p++) {
          const page = await pdf.getPage(p);
          const tc = await page.getTextContent();
          const text = (tc.items || []).map(i => i.str).join(' ');
          doc.pages.push(text);
        }
        return doc;
      }

      function splitSentences(text){
        return (text||'')
          .replace(/\s+/g,' ')
          .split(/(?<=[\.!?])\s+(?=[A-Z0-9])/)
          .map(s=>s.trim()).filter(Boolean);
      }

      function buildIndex(docs){
        index = [];
        docNames = docs.map(d=>d.name);
        docs.forEach((d, di)=>{
          d.pages.forEach((txt, pi)=>{
            splitSentences(txt).forEach(s=>{
              const toks = tokens(s);
              if (toks.length > 3) {
                index.push({ doc: di, page: pi+1, text: s, tokens: toks });
              }
            });
          });
        });
      }

      function scoreSentence(qTokens, sent){
        const set = new Set(sent.tokens);
        let hits = 0; qTokens.forEach(t => { if (set.has(t)) hits++; });
        const lenBonus = 0.2 / Math.sqrt(sent.tokens.length);
        return hits + lenBonus;
      }

      function answer(query){
        const qTokens = tokens(query);
        if (!qTokens.length) return { summary:'', cites:[] };
        const scored = index.map(s => ({ s, score: scoreSentence(qTokens, s) }))
                            .filter(x => x.score > 0)
                            .sort((a,b) => b.score - a.score)
                            .slice(0, 6);
        const seen = new Set(), cites = [], chosen = [];
        for (const { s } of scored) {
          const key = s.doc + '-' + s.page;
          if (!seen.has(key)) { seen.add(key); cites.push({ doc: s.doc, page: s.page, text: s.text }); }
          chosen.push(s.text);
          if (cites.length >= 3) break;
        }
        const uniqueChosen = Array.from(new Set(chosen)).slice(0, 5);
        return { summary: uniqueChosen.join(' '), cites };
      }

      // Index PDFs
      document.getElementById('kb-index').addEventListener('click', async ()=>{
        try{
          guardPdfjs();
          const files = Array.from(filesEl.files || []).slice(0,3);
          if (!files.length) { statusEl.textContent = 'Please choose 1–3 PDFs (text-based, not scanned).'; return; }
          statusEl.textContent = 'Reading PDFs…';
          const docs = [];
          for (const f of files) docs.push(await extractPDF(f));
          buildIndex(docs);
          statusEl.textContent = `Indexed ${docs.length} document(s), ${index.length} sentence chunks.`;
          askBtn.disabled = false; askBtn.classList.add('btn-dark'); askBtn.style.background = '#111';
          outEl.style.display = 'none';
          dbgEl.textContent = JSON.stringify({ docs: docNames, chunks: index.length }, null, 2);
        } catch(e){ showError('Failed to read PDFs', e); }
      });

      // Answer
      askBtn.addEventListener('click', ()=>{
        try{
          const q = qEl.value.trim();
          if (!q) return;
          const res = answer(q);
          outEl.style.display = 'block';
          const citeHtml = res.cites.map(c=>{
            const dn = docNames[c.doc] || `Doc ${c.doc+1}`;
            const snip = c.text.length > 140 ? c.text.slice(0,137) + '…' : c.text;
            return `<div class="pill" style="margin:6px 0">
              <div class="muted"><strong>${dn}</strong> • Page ${c.page}</div>
              <div style="margin-top:4px">${snip.replace(/</g,'&lt;')}</div>
            </div>`;
          }).join('');
          outEl.innerHTML = `
            <div style="margin-bottom:8px"><strong>Answer (extractive)</strong></div>
            <div>${res.summary || '<em>No clear answer found.</em>'}</div>
            <div style="margin-top:10px"><strong>Citations</strong></div>
            ${citeHtml || '<em>No relevant citations.</em>'}
            <div class="muted" style="margin-top:8px">Demo logic: keyword retrieval over sentence chunks; plug a server LLM for abstractive answers.</div>
          `;
          // Capture a clean text version for download
          const citationsPlain = res.cites.map(c=>{
            const dn = docNames[c.doc] || `Doc ${c.doc+1}`;
            return `- ${dn} • Page ${c.page}: ${c.text}`;
          }).join('\n');
          lastAnswerText =
            `Question: ${q}\n\nAnswer (extractive):\n${res.summary || '(no clear answer)'}\n\nCitations:\n${citationsPlain || '(none)'}`;
        } catch(e){ showError('Failed to answer', e); }
      });

      // Reset
      document.getElementById('kb-reset').addEventListener('click', ()=>{
        filesEl.value = '';
        qEl.value = '';
        outEl.style.display = 'none';
        outEl.innerHTML = '';
        statusEl.textContent = 'Ready. Choose 1–3 PDFs and click Index PDFs.';
        askBtn.disabled = true; askBtn.style.background = '#999'; askBtn.style.cursor = 'not-allowed';
        dbgEl.textContent = '';
        index = []; docNames = []; lastAnswerText = '';
      });

      // Download answer
      document.getElementById('kb-save').addEventListener('click', ()=>{
        if (!lastAnswerText) { alert('No answer to download yet. Ask a question first.'); return; }
        const blob = new Blob([lastAnswerText + '\n'], {type:'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'kbqa-answer.txt';
        document.body.appendChild(a); a.click();
        URL.revokeObjectURL(url); a.remove();
      });
    })();
  </script>

  <script>
/* Post height to parent (Carrd) so the iframe can auto-resize */
(function(){
  function sendHeight(){
    var h = Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
    parent.postMessage({ kbqaHeight: h }, '*');
  }
  window.addEventListener('load', sendHeight);
  // Update on content changes/resizes
  var ro = new ResizeObserver(sendHeight);
  ro.observe(document.body);
  window.addEventListener('click', sendHeight);
  window.addEventListener('input', sendHeight);
})();
</script>

  
</body>
</html>
